#+TITLE: React
🔴 

* pnpm + Vite + urql

** pnpm:
npm 的替代 速度快， 空间占用科学
** Vite:
app 生成脚手架
*** 步骤：
pnpm init vite-app gh-explorer --template react
cd gh-explorer
pnpm i
pnpm dev
* ES6 模块化
+ 暴露：
  + 分别暴露，统一暴露
    #+BEGIN_SRC js

    // 分别暴露
    export function sum(a, b) {
        return a + b
    }

    // 统一暴露
    function sub(a, b) {
        return a - b
    }
    // export { sub as sub };
    export { sub };
    // 统一暴露
    #+END_SRC
  + 默认暴露
    #+BEGIN_SRC js

    // 默认暴露
    export default {
        mul: function(a, b) {
            return a*b
        },

        div: function(a, b) {
            return a/b
        },

        // 或者   简写方式
        mul1(a, b) {
            return a*b
        },
        div(a, b) {
            return a/b
        }
    }
    #+END_SRC
+ 引入：
    #+BEGIN_SRC js
        import { sum } from './module1';
        import { sub } from './module2';
        import module3 from './module3';


        console.log(sum(1, 3))
        console.log(sub(3, 1))
        console.log(module3.div(4/2))

    #+END_SRC`
  1. import {} from './xx/xx'
  2. import a from './xxx/xx'

   
* jsx 
** 语法规则
+ className
+ {}  里面写 js
 ⚠️注意：{} 里面只能写表达式，言外之意 function 或者 箭头函数
 一个表达式 会产生一个值
+ 最外层 只能包含一个 标签，（最后外面套一个 div 一般）
+ 组件 标签首字母大写
+ 
** 作用
简化创建 react 虚拟 dom 的创建，
创建的其实是虚拟 dom
** 其他
babel 可以吧 jsx 转化成 js
* react 面向组件编程
** 创建组件的两种方式
*** 工厂函数定义组件
这种 组件其实是一个函数 (函数名首字母大写), 在 jsx 里面 用标签调用, jsx 渲染 这个函数的返回值
#+BEGIN_SRC js react
function Mycoponent() {
  return <h2>fuck</h2>
}

# html
<Mycoponent/>

#+END_SRC
*** es6 类组件
#+BEGIN_SRC js react
class Myconponent2 extends React.Component {
  // 构造器 new 的时候 初始化用
  constructor(a) {
    super(a)
  }

  // 重写从父类继承的 render
  render() {
    return <h2>es6 类组件创建的 复杂组件</h2>
  }
}

#+END_SRC
** 组件三大属性
*** state
特点 state 就叫 state， 1.不能直接更新， 2.不能直接修改， （借助 setState 方法）
Component 里面 自己定义的方法 拿不到 this 需要 bind this （react 底层弊端， vue 没这个问题）
#+BEGIN_SRC js react

class Weather extends React.Component {
  constructor(a) {
    super(a)
    this.state = {isHot:true}
    this.changeWeather = this.changeWeather.bind(this)
  }

  render() {
    let { isHot } = this.state

    return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '热' : '冷'}</h1>
  }

  // 自己写的方法， 里面想使用 this 会报 undefined， 必须用 bind (react 底层的问题， vue 没有这个问题)
  changeWeather() {
    // console.log(this)
    // this.state.isHot = !this.state.isHot
    // 组件实例的 state: 1. 不能直接修改 2.不能直接更新
    this.setState({isHot: !this.state.isHot})

  }
}

#+END_SRC

**** setState
+ setState 属于更新操作，(更新的 可能不是全部舒适化的变量)
+ 必须更新初始化存在过的变量
**** bind(this)
在 Component 中的自己定义的方法 this  访问不到这个实例，所以需要 用 bind(this)
**** state 的简写方式
+ 利用了 class 里面 直接定义属性，和箭头函数里面没有 this，没有 this 会向外找的特点，这时就找到了 class 的 this
+ 相当于 不使用 constructor 构造器
  
#+BEGIN_SRC js react
class Weather extends React.Component {
    // class 里面直接定义 变量名=xxx this可以直接访问到
  state = {isHot:true}

  render() {
    let { isHot } = this.state

    return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '热' : '冷'}</h1>
  }

// 利用 变量=匿名函数，使变量名可以被this 访问到，而且 匿名函数里面本身没有this，但是匿名函数的this 和他外层的this 一致
  changeWeather = () => {
    this.setState({isHot: !this.state.isHot})

  }
}

#+END_SRC
*** props
翻译过来 参数的意思
其实就是 jsx 中 的组件在调用并传值的时候 class 内部可以访问到这部分值的一种防方式
#+BEGIN_SRC js react
import PropTypes from 'prop-types';

<Person name="kobe" age={18} sex="男"/>


class Person extends React.Component{
  render() {
    let { name, age, sex } = this.props
    return (
      <ul>
        <li>{name}</li>
        <li>{sex}</li>
        <li>{age}</li>
      </ul>
    )
  }
}

// 设定 props type 属性 和默认值
Person.propTypes = {
  name: PropTypes.string.isRequired,
    age: PropTypes.number,
    sex: PropTypes.string,
}
Person.defaultProps = {
  name: 'Stranger',
  age: 10,
  sex: "不男不女",
};

#+END_SRC

**** props 的简写
#+BEGIN_SRC js react
class Person extends React.Component{
  static propTypes = {
    name: PropTypes.string.isRequired,
    age: PropTypes.number,
    sex: PropTypes.string,
  }

  static defaultProps = {
    age: 10,
    sex: "不男不女",
  }

  render() {
    let { name, age, sex } = this.props
    return (
      <ul>
        <li>{name}</li>
        <li>{sex}</li>
        <li>{age}</li>
      </ul>
    )
  }
}

#+END_SRC


**** props 传参的简写
正常来说 。。。 解包 只能用 解包数组， 但是 如果用 {} 阔上解包  可以解包对象
#+BEGIN_SRC js react

// 正常
<Person name="kobe" age={18} sex="男"/>

// 解包
let person2 = {name:"sb", age:18, sex:"女"}
<Person {...person2}/>

#+END_SRC
*** ref
ref 和 refs 就是类似 id 一样给标签做标记，方便找到
ref 标记， this.refs 拿到标记的标签
🔴注意️：能不用就不用，event 有时候也可以
#+BEGIN_SRC js react
class MyComponent extends React.Component{

  clickButton = () => {
    alert(this.refs.input1.value)
  }

  blurHandler = (event) => {
    alert(event.target.value)
  }

  render() {
    return (
      <div>
        // 注意 这个方式已经被遗弃
        <input name="" type="text" ref="input1"/>&nbsp;
        <button onClick={this.clickButton}>click</button>&nbsp;
        <input name="" type="text" placeholder='点点点点' onBlur={this.blurHandler}/>
      </div>
    )
  }
}

#+END_SRC
**** ref 新写法(基于回调)

原理：react 会调用 ref， 并把当前节点 传入给 ref 表达式, 然后手动指定变量 赋值给当前节点
<input type="text" ref={ (input) => {this.input1 = input} }/>&nbsp;
<input type="text" ref={ input => this.input1 = input }/>&nbsp;

#+BEGIN_SRC js react
class MyComponent extends React.Component{

  clickButton = () => {
    alert(this.myTargetInput.value)
  }

  blurHandler = (event) => {
    alert(event.target.value)
  }

  render() {
    return (
      <div>
        <input type="text" ref={ input => this.myTargetInput = input }/>&nbsp;
        <button onClick={this.clickButton}>click</button>&nbsp;
        <input type="text" placeholder='点点点点' onBlur={this.blurHandler}/>
      </div>
    )
  }
}

#+END_SRC
**** ref 新写法(基于 createRef)
利用 React.createRef() 创建一个容器（专用）

#+BEGIN_SRC js react
class MyComponent extends React.Component{

  myRef = React.createRef()

  clickButton = () => {
    alert(this.myRef.current.value)
  }

  blurHandler = (event) => {
    alert(event.target.value)
  }

  render() {
    return (
      <div>
        <input type="text" ref={ this.myRef }/>&nbsp;
        <button onClick={this.clickButton}>click</button>&nbsp;
        <input type="text" placeholder='点点点点' onBlur={this.blurHandler}/>
      </div>
    )
  }
}
#+END_SRC
** 组件的组合
组合 写个 todo list 点 button 就添加一个 todo list
#+BEGIN_SRC js react
class MyApp extends React.Component{
  state = {
    todoArr: ['吃饭', '睡觉', '打豆豆']
  }
  render() {
    let {todoArr} = this.state
    return (
      <div>
        <h1>yidvslkdfjskfdj</h1>
        <Add updateArr={this.updateTodoArr} arrLength={todoArr.length}/>
        <List arr={ todoArr }/>
      </div>
    )
  }

  // state 在哪里 更新的方法就在哪里
  updateTodoArr = (newstr) => {
    // 必须重新赋值， 原state 不可改动
    let newarr = this.state.todoArr
    newarr.push(newstr)
    this.setState(newarr)
  }
}

class Add extends React.Component{
  render() {
    let { arrLength } = this.props
    return (
      <div>
        <input type="text" ref={ (input) => { this.addContent = input } }/>
      <button onClick={this.buttonHandler}>add #{arrLength}</button>
      </div>
    )
  }

  // 不能直接更新 存在于父级的 state, 就利用 父级给的 更新方法更新 state
  buttonHandler = () => {
    let { updateArr } = this.props
    updateArr(this.addContent.value)
    this.addContent.value = ''
  }
}

class List extends React.Component{
  render() {
    let { arr } = this.props
    return (
      <ul>
      {
        arr.map((item, index)=>{
          return <li key={index}>{item}</li>
        })
      }
      </ul>
    )
  }
}
#+END_SRC
** 受控组件 非受控组件
就看是否 自动维护 value 到 state， 维护到 state 的就是受控组件
** 生命周期函数(钩子)(旧的)
+ 🟢 挂载 componentDidMount()  
  开定时器， 发 ajax 请求
+ 🟢 卸载 componentWillUnmount()
  做一些收尾性的工作 
+ componentWillReceiveProps()    从第二次开始算(父组件更新状态的时候)
+ forceUpdate()   强制更新
+ shouldComponentUpdate()  
+ 更新 componentWillUPdate()
*** 流程
componentWillMount()   ->   render()  -> componentDidMount()
componentWillUpdate()  ->   render()  -> componentDidUpdate()
*** 将要废弃的钩子
一共 4 个 will 废弃了 3 个， 剩一下 componentWillUnmount
+ componentWillMount()
+ componentWillReceiveProps()
+ componentWillUpdate()
***  新流程
**** getDerivedStateFromProps
+ 🔴 getDerivedStateFromProps
  + should be a static method
  + must have return, null or object, return 的对象会对 state 做更新, 没重名追加，有重名更新
  + 用于取代 willMount, willUpdate
#+BEGIN_SRC js react 
static getDerivedStateFromProps(props, state){
    return {a: 1}
}
#+END_SRC
**** getsnapshotbeforeupdate

**** 挂载时
constructor -> getDerivedStateFromProps -> render -> componentDidMount
**** 更新时
getDerivedStateFromProps -> shouldComponentUpdate -> render -> getsnapshotbeforeupdate -> componentDidUpdate
**** 卸载时
componentWillUnmount
** react 中的 key


